package flux

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)


type RouteManager struct {
	app    *Application
	routes []RouteDoc
}


type RouteDoc struct {
	Method      string
	Path        string
	Handler     string
	Description string
}


func NewRouteManager(app *Application) *RouteManager {
	return &RouteManager{
		app:    app,
		routes: []RouteDoc{},
	}
}


func (rm *RouteManager) Add(method, path, handler, description string) {
	rm.routes = append(rm.routes, RouteDoc{
		Method:      method,
		Path:        path,
		Handler:     handler,
		Description: description,
	})
}


func (rm *RouteManager) AddFromRoute(route *Route, handlerName string) {
	rm.Add(route.Method, route.Path, handlerName, route.Description)
}


func (rm *RouteManager) GenerateRoutesFile(outputDir string) error {
	if outputDir == "" {
		outputDir = "."
	}

	
	if err := os.MkdirAll(filepath.Join(outputDir, "routes"), 0755); err != nil {
		return fmt.Errorf("failed to create routes directory: %w", err)
	}

	
	file, err := os.Create(filepath.Join(outputDir, "routes", "generated_routes.go"))
	if err != nil {
		return fmt.Errorf("failed to create routes file: %w", err)
	}
	defer file.Close()

	
	moduleName := getCurrentModuleName(outputDir)
	
	
	fmt.Fprintln(file, "// Code generated by flux framework; DO NOT EDIT.")
	fmt.Fprintln(file, "package routes")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "import (")
	fmt.Fprintln(file, "\t\"github.com/Fluxgo/flux/pkg/flux\"")
	fmt.Fprintln(file, "\t\"github.com/gofiber/fiber/v2\"")
	
	
	controllersImported := false
	if _, err := os.Stat(filepath.Join(outputDir, "app", "controllers")); err == nil {
		fmt.Fprintf(file, "\t\"%s/app/controllers\"\n", moduleName)
		controllersImported = true
	}
	
	fmt.Fprintln(file, ")")
	fmt.Fprintln(file, "")

	
	fmt.Fprintln(file, "// RegisterRoutes registers all application routes")
	fmt.Fprintln(file, "func RegisterRoutes(app *flux.Application) {")

	
	groupedRoutes := groupRoutesByPath(rm.routes)

	
	if len(groupedRoutes) > 0 {
		
		if directRoutes, ok := groupedRoutes["/"]; ok {
			for _, route := range directRoutes {
				handlerName := getHandlerFuncName(route.Handler, controllersImported)
				fmt.Fprintf(file, "\t// %s\n", route.Description)
				fmt.Fprintf(file, "\tapp.%s(\"%s\", %s)\n", route.Method, route.Path, handlerName)
			}
			fmt.Fprintln(file, "")
		}

		
		for basePath, routes := range groupedRoutes {
			if basePath == "/" {
				continue 
			}
			
			groupName := getGroupVarName(basePath)
			fmt.Fprintf(file, "\t// %s group\n", strings.TrimPrefix(basePath, "/"))
			fmt.Fprintf(file, "\t%s := app.Group(\"%s\")\n", groupName, basePath)
			fmt.Fprintln(file, "\t{")
			
			
			for _, route := range routes {
				path := strings.TrimPrefix(route.Path, basePath)
				if path == "" {
					path = "/"
				}
				
				handlerName := getHandlerFuncName(route.Handler, controllersImported)
				fmt.Fprintf(file, "\t\t// %s\n", route.Description)
				fmt.Fprintf(file, "\t\t%s.%s(\"%s\", %s)\n", groupName, strings.ToLower(route.Method), path, handlerName)
			}
			
			fmt.Fprintln(file, "\t}")
			fmt.Fprintln(file, "")
		}
	}

	fmt.Fprintln(file, "}")

	return nil
}

// Helper functions for route generation
func groupRoutesByPath(routes []RouteDoc) map[string][]RouteDoc {
	groupedRoutes := make(map[string][]RouteDoc)
	
	for _, route := range routes {
		parts := strings.Split(route.Path, "/")
		if len(parts) <= 1 {
			
			groupedRoutes["/"] = append(groupedRoutes["/"], route)
		} else {
			basePath := "/" + parts[1]
			groupedRoutes[basePath] = append(groupedRoutes[basePath], route)
		}
	}
	
	return groupedRoutes
}

func getGroupVarName(path string) string {
	name := strings.TrimPrefix(path, "/")
	if name == "" {
		return "rootGroup"
	}
	return name + "Group"
}

func getHandlerFuncName(handler string, controllersImported bool) string {
	
	if controllersImported && strings.Contains(handler, ".") {
		parts := strings.Split(handler, ".")
		if len(parts) == 2 {
			return "controllers." + handler
		}
	}
	
	
	return handler
}

func getCurrentModuleName(dir string) string {
	
	data, err := os.ReadFile(filepath.Join(dir, "go.mod"))
	if err != nil {
		return "app"
	}
	
	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module"))
		}
	}
	
	return "app"
}


func (rm *RouteManager) GenerateControllerRoutes(outputDir, controllerName string, routes []RouteDoc) error {
	if outputDir == "" {
		outputDir = "."
	}

	
	if err := os.MkdirAll(filepath.Join(outputDir, "routes"), 0755); err != nil {
		return fmt.Errorf("failed to create routes directory: %w", err)
	}

	
	controllerRoutes := []RouteDoc{}
	for _, route := range rm.routes {
		if strings.Contains(route.Handler, controllerName) {
			controllerRoutes = append(controllerRoutes, route)
		}
	}

	
	controllerRoutes = append(controllerRoutes, routes...)

	
	groupedRoutes := groupRoutesByPath(controllerRoutes)

	
	file, err := os.Create(filepath.Join(outputDir, "routes", strings.ToLower(controllerName)+"_routes.go"))
	if err != nil {
		return fmt.Errorf("failed to create controller routes file: %w", err)
	}
	defer file.Close()

	
	fmt.Fprintln(file, "package routes")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "import (")
	fmt.Fprintln(file, "\t\"github.com/Fluxgo/flux/pkg/flux\"")
	fmt.Fprintln(file, "\t\"github.com/gofiber/fiber/v2\"")

	
	moduleName := getCurrentModuleName(outputDir)
	if _, err := os.Stat(filepath.Join(outputDir, "app", "controllers")); err == nil {
		fmt.Fprintf(file, "\t\"%s/app/controllers\"\n", moduleName)
	}

	fmt.Fprintln(file, ")")
	fmt.Fprintln(file, "")

	
	fmt.Fprintf(file, "// Register%sRoutes registers all %s routes\n", controllerName, controllerName)
	fmt.Fprintf(file, "func Register%sRoutes(app *flux.Application) {\n", controllerName)
	fmt.Fprintf(file, "\t// Initialize controller\n")
	fmt.Fprintf(file, "\tcontroller := &controllers.%sController{}\n", controllerName)
	fmt.Fprintf(file, "\tapp.RegisterController(controller)\n\n")

	
	fmt.Fprintln(file, "\t/* Alternative manual registration:")
	fmt.Fprintf(file, "\t%s := app.Group(\"/%s\")\n", strings.ToLower(controllerName)+"Group", strings.ToLower(controllerName))
	fmt.Fprintln(file, "\t{")

	
	for _, routes := range groupedRoutes {
		for _, route := range routes {
			path := route.Path
			if strings.HasPrefix(path, "/"+strings.ToLower(controllerName)) {
				path = strings.TrimPrefix(path, "/"+strings.ToLower(controllerName))
				if path == "" {
					path = "/"
				}
			}

			handlerName := route.Handler
			if strings.Contains(handlerName, ".") {
				parts := strings.Split(handlerName, ".")
				if len(parts) == 2 {
					handlerName = parts[1]
				}
			}

			fmt.Fprintf(file, "\t\t%s.%s(\"%s\", func(c *fiber.Ctx) error {\n", 
				strings.ToLower(controllerName)+"Group", 
				strings.ToLower(route.Method), 
				path)
			fmt.Fprintln(file, "\t\t\tctx := flux.NewContext(c, app)")
			fmt.Fprintf(file, "\t\t\treturn controller.%s(ctx)\n", handlerName)
			fmt.Fprintln(file, "\t\t})")
		}
	}

	fmt.Fprintln(file, "\t}")
	fmt.Fprintln(file, "\t*/")
	fmt.Fprintln(file, "}")

	return nil
}


func (rm *RouteManager) SortRoutes() {
	sort.Slice(rm.routes, func(i, j int) bool {
		if rm.routes[i].Path == rm.routes[j].Path {
			return rm.routes[i].Method < rm.routes[j].Method
		}
		return rm.routes[i].Path < rm.routes[j].Path
	})
}
